.. _transaction:

.. role:: raw-html(raw)
   :format: html

数据库事务
==========
ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)

数据库事务级别 
--------------
**脏读（dirty read）:**
  1. 事务T1更新了一行记录的内容，但是并没有提交所做的修改
  2. 事务T2读取更新后的行，然后T1执行回滚操作，取消了刚才所做的修改
  3. 现在T2所读取的行就无效了

**不可重复读（nonrepeatable read）:**
  1. 事务T1读取一行记录，紧接着事务T2修改了T1刚才读取的那一行记录
  2. 然后T1又再次读取这行记录，发现与刚才读取的结果不同

**幻像读（phantom read）:**
  1. 事务T1读取一条指定的WHERE子句所返回的结果集
  2. 然后事务T2新插入一行记录，这行记录恰好满足T1所使用的查询条件
  3. 然后T1又使用相同的查询再次对表进行检索，此时却看到了事务T2刚才插入的新行

InnoDB和XtraDB存储引擎通过MVCC解决了幻像读的问题

  MVCC（Multiversion Concurrency Control）是行级锁的一个变种

* 只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作
* 在很多情况下避免了加锁操作，因此开销更低
* 实现了非阻塞的读操作，写操作也只锁定必要的行
 
InnoDB 的MVCC是通过在每行记录后面保存两个隐藏列实现的

* 这两个列，一个保存了行的创建时间，一个保存行的过期时间(或删除时间)
* 存储的不是实际的时间值，而是系统版本号（每开始一个新事务版本号都会自动递增）

事务的隔离级别，从级别低到高依次为：

  较低级别的隔离通常可以执行更高的并发，系统的开销也更低

.. table::
   :class: classic

   +----------------+-----------+-----------+-----------+-----------------------------+
   | \\             |    脏读   |不可重复读 |   幻像读  |           备注              |
   +================+===========+===========+===========+=============================+
   |READ UNCOMMITTED| **`Yes`** | **`Yes`** | **`Yes`** | \-                          |
   +----------------+-----------+-----------+-----------+-----------------------------+
   |READ COMMITTED  | **`No`**  | **`Yes`** | **`Yes`** | \-                          |
   +----------------+-----------+-----------+-----------+-----------------------------+
   |REPEATABLE READ | **`No`**  | **`No`**  | **`Yes`** | InnoDB默认级别              |
   +----------------+-----------+-----------+-----------+-----------------------------+
   |SERIALIZABLE    | **`No`**  | **`No`**  | **`No`**  | 会在读取的每一行数据上都加锁|
   +----------------+-----------+-----------+-----------+-----------------------------+

ORACLE数据库

  支持 READ COMMITTED 和 SERIALIZABLE :raw-html:`<br />`
  不支持 READ UNCOMMITTED 和 REPEATABLE READ

事务实现相关
--------------
事务日志是以追加的方式实现的: 存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。

事务数据库系统普遍都采用了 Write Ahead Log 策略

	即当事务提交时，先写重做日志再修改页

分布式XA事务让存储引擎级别的ACID 可以扩展到数据库层面

MySQL 服务器层不管理事务，事务是由下层的存储引擎实现的（事务标识是一个 64 比特的数字）

MySQL 提供了两种事务型的存储引擎：InnoDB、NDB Cluster

InnoDB 用日志把随机I/O变成顺序I/O（日志是环形方式写的）

* 一旦日志安全写到磁盘，事务就持久化了，即使变更还没写到数据文件
* 如果发生了一些意外（例如断电），InnoDB 可以重放日志并且恢复已经提交的事务







